
\myparagraph{Пространственная фильтрация}

Пространственная фильтрация является одним из популярных способов обработки изображений - с ее помощью могут быть решены следующие задачи:

\begin{itemize}

	\item устранение помех различного рода (например, устранение импульсных помех);
	\item сглаживание изображения (фильтры низких частот);
	\item повышение резкости изображения, выделение контуров на изображении (фильтры высоких частот);
	\item прочие задачи.

\end{itemize}

Пространственная фильтрация, в отличии от частотной фильтрации, работает со значениями яркостей пикселей в каждом из спектральных каналов изображения. Если изображение состоит из нескольких каналов, то пространственный фильтр применяется, чаще всего, к каждому из каналов независимо. Результатом пространственной фильтрации являются несколько матриц, размер и количество которых равны размеру исходного изображения и количеству каналов в нем.

Пусть имеется исходное одноканальное изображение $I$ \eqref{ip:2:I} размером $M$ строк на $N$ столбцов:
\begin{gather}
	\label{ip:2:I}
	I = \left(
	\begin{array}{cccc}
		i_{11} & i_{12} & ... & i_{1N}\\
		i_{21} & i_{22} & ... & i_{2N}\\
		... & ... & ... & ...\\
		i_{M1} & i_{M2} & ... & i_{MN}
	\end{array}
	\right),
\end{gather}

где $i_{mn} ;~ m = \overline{1, M} ;~ n = \overline{1, N}$ - яркость пикселя, расположенного в $m$-ой строке $n$-го столбца. В общем случае, $i_{mn} \in \mathbb{R} ;~ i_{mn} \ge 0$ (то есть $i_{mn} \in R^+$), однако часто $i_{mn} \in Z ;~ i_{mn} \in [ 0 ;~ 255 ]$.

Результатом работы пространственного фильтра $F$ является матрица $R = F(I)$ \eqref{ip:2:R} размером $M$ строк на $N$ столбцов:
\begin{gather}
	\label{ip:2:R}
	R = \left(
	\begin{array}{cccc}
		r_{11} & r_{12} & ... & r_{1N}\\
		r_{21} & r_{22} & ... & r_{2N}\\
		... & ... & ... & ...\\
		r_{M1} & r_{M2} & ... & r_{MN}
	\end{array}
	\right),
\end{gather}

где $r_{mn} = F(i_{mn}) ;~ r_{mn} \in \mathbb{R} ;~ m = \overline{1, M} ;~ n = \overline{1, N}$. Значения $r_{mn}$ могут быть, в общем случае, отрицательными, поэтому некорректно называть матрицу $R$ новым изображением.

Алгоритм работы пространственного фильтра состоит в последовательном обходе всех пикселей изображения $I$ и расчете соответствующих компонент матрицы $R$.

Новое изображение может быть получено из матрицы $R$ путем некоторого ее преобразования, выполняющего масштабирование диапазона возможных значений компонент матрицы $R$ в диапазон возможных значений яркостей пикселей.

Существует несколько подходов к построению пространственного фильтра $F$, самый распространенный из которых состоит в задании некоторого ядра $K$ свертки \eqref{ip:2:K}:
\begin{gather}
	\label{ip:2:K}
	K = \left(
	\begin{array}{cccc}
		k_{11} & k_{12} & ... & k_{1N^*}\\
		k_{21} & k_{22} & ... & k_{2N^*}\\
		... & ... & ... & ...\\
		k_{M^*1} & k_{M^*2} & ... & k_{M^*N^*}
	\end{array}
	\right),
\end{gather}

где: $M^* \le M$ и $N^* \le N$. Часто $M^* \ll M$ и $N^* \ll N$.

Один из элементов ядра $K$: $k_{m^{c*} n^{c*}}$ - является центром ядра (выполнение условий $m^{c*} = \dfrac{M^*}{2}$ и $n^{c*} = \dfrac{N^*}{2}$ не является обязательным).

В данном случае фильтр $F$ описывается формулой \eqref{ip:2:F:main}:
\begin{gather}
	\label{ip:2:F:main}
	r_{mn} = F(i_{mn}) = \sum_{m^* = 1}^{M^*} \sum_{n^* = 1}^{N^*} k_{m^* n^*} i_{(m - m^{c*} + m^*) (n - n^{c*} + n^*)}.
\end{gather}

Проще говоря, пространственный фильтр, задаваемый своим ядром, рассчитывает для каждого пикселя изображения $I$ взвешенную сумму его значения и значений его соседей, помещая центр ядра в пиксель и используя значения элементов ядра в качестве весов значений пикселей, расположенных по соседству.

На границах изображения $I$ в случае, если не выполняется одно из условий $1 \le m - m^{c*} + m^* \ge M$ и $1 \le n - n^{c*} + n^* \ge N$, вместо значения не существующего пикселя $i_{(m - m^{c*} + m^*) (n - n^{c*} + n^*)}$ используется <<фиктивное>> значение - например, 0.

Вычислительная сложность обобщенной реализации пространственного фильтра, основанного на использовании ядра свертки, составляет $O(N^2)$. Алгоритм применения пространственного фильтра может быть эффективно распараллелен в многопроцессорных вычислительных системах и на вычислительных кластерах из-за независимости расчета значений элементов результирующей матрицы и неизменности исходного изображения в процессе применения фильтра. Применение отдельных фильтров может быть существенно ускоренно за счет кэширования.

Существуют также другие способы построения пространственного фильтра $F$, о некоторых из которых будет сказано далее.

Библиотека OpenCV реализует пространственную фильтрацию изображений в виде набора соответствующих функций, одной из которых является функция \verb|filter2D()|. Прототип функции \verb|filter2D()| приведен в листинге \ref{listing:ip:2:filter}.

\mylistingbegin{ip:2:filter}{Пространственная фильтрация изображений с помощью функции filter2D()}
\begin{lstlisting}

void filter2D(Mat I, Mat & R, -1, Mat K);

\end{lstlisting}
\mylistingend

Центром ядра является центральный элемент матрицы $K$.

\mysubparagraph{Фильтры низких частот}

Фильтры низких частот уменьшают амплитуды высокочастотных составляющих в спектре изображения, следствием чего являются:

\begin{itemize}

	\item сглаживание контуров на изображении;
	\item размытость изображения;
	\item частичное или полное устранение импульсных помех.

\end{itemize}

Наиболее популярными являются следующие фильтры низких частот:

\begin{itemize}

	\item однородные нормализованные фильтры.

	Элементы ядер \eqref{ip:2:blur} таких фильтров равны между собой:
	\begin{gather}
		\label{ip:2:blur}
		K = \{ \dfrac{1}{M^*N^*} \} = \dfrac{1}{M^*N^*} \{ 1 \}\\
		m^{c*} = \dfrac{M^*}{2} ;~ n^{c*} = \dfrac{N^*}{2},
	\end{gather}

	то есть ядра однородных нормализованных фильтров заполнены единицами и после применения фильтра к изображению происходит домножение результирующей матрицы $R$ на коэффициент $\dfrac{1}{M^*N^*}$. Таким образом, однородные нормализованные фильтры усредняют пиксели исходного изображения по соседним пикселям, что приводит к сглаживанию (размытию) изображения.

	В библиотеке OpenCV однородный нормализованный фильтр реализован в виде функции \verb|blur()|, прототип которой приведен в листинге \ref{listing:ip:2:blur}.

	\mylistingbegin{ip:2:blur}{Применение к изображению однородного нормализованного фильтра с помощью функции blur()}
	\begin{lstlisting}

	void blur(Mat I, Mat & R, Size MN);

	\end{lstlisting}
	\mylistingend

	Размер ядра задается параметром \verb|MN|;

	\item фильтр Гаусса.

	Фильтр Гаусса основан на использовании двухмерной функции Гаусса \eqref{ip:2:gauss}:
	\begin{gather}
		\label{ip:2:gauss}
		g(x, y) = \dfrac{1}{2 \pi \sigma^2}e^{-\dfrac{x ^ 2 + y ^ 2}{2 \sigma ^ 2}}.
	\end{gather}

	График двухмерной функции Гаусса приведен на рисунке \ref{image:ip:2:gauss}.

	По значениям функции Гаусса составляется ядро $K$ фильтра, при этом центр ядра совмещается с пиком функции. Фильтр Гаусса сохраняет доминирующее влияние пикселя, попадающего в центр ядра, но при этом учитывает значения соседних пикселей, что приводит к незначительному сглаживанию (размытию) исходного изображения.

	В библиотеке OpenCV фильтр Гаусса реализован в виде функции \verb|GaussianBlur()|, прототип которой приведен в листинге \ref{listing:ip:2:gauss}.
	\mylistingbegin{ip:2:gauss}{Применение к изображению фильтра Гаусса с помощью функции GaussianBlur()}
	\begin{lstlisting}

	void GaussianBlur(Mat I, Mat & R, Size MN, double sigma);

	\end{lstlisting}
	\mylistingend

	Параметр \verb|sigma| функции \verb|GaussianBlur()| позволяет указать значение параметра $\sigma$ функции Гаусса, влияющего на остроту пика функции (чем меньше абсолютное значение параметра \verb|sigma|, тем пик острее и наоборот).

\end{itemize}

\def\sgm{1.5}

\mimagebegin{ip:2:gauss}{Двухмерная функция Гаусса ($\sigma = $ \sgm)}
\noindent
\begin{tikzpicture}

	\begin{axis}[xlabel = $x$, ylabel = $y$, width = \textwidth]

		\addplot3[surf] {1 / (2 * pi * \sgm ^ 2) * exp(- (x * x + y * y) / (2 * \sgm ^ 2)};

	\end{axis}
	
\end{tikzpicture}
\mimageend
	
\begin{itemize}

	\item медианный фильтр.
	
	Медианный фильтр относится к классу пространственных фильтров, не описываемых ядром свертки. Медианный фильтр обходит все пиксели исходного изображения $I$, помещая очередной пиксель в центр специального окна. Медианный фильтр сортирует по возрастанию значения яркостей пикселей, попавших в окно, после чего присваивает элементу результирующей матрицы значение яркости пикселя, оказавшегося в середине отсортированной последовательности пикселей, попавших в окно. Таким образом, медианный фильтр позволяет эффективно избавится от импульсных помех, присутствующих на исходном изображении.

	В библиотеке OpenCV медианный фильтр реализован в виде функции \verb|medianBlur()|, прототип которой приведен в листинге \ref{listing:ip:2:median}.

	\mylistingbegin{ip:2:median}{Применение к изображению медианного фильтра с помощью функции medianBlur()}
	\begin{lstlisting}

	void medianBlur(Mat I, Mat & R, int ksize);

	\end{lstlisting}
	\mylistingend

	Формальный параметр \verb|ksize| функции \verb|medianBlur()| задает размер квадратного окна, которым медианный фильтр обходит изображение.

\end{itemize}

\mysubparagraph{Фильтры высоких частот}

Фильтры высоких частот выделяют высокочастотные составляющие спектра изображения, удаляя при этом низкочастотные. Результатом применения фильтра высоких частот является контурное изображение, которое в дальнейшем может быть прибавлено к исходному изображению с целью усиления высокочастотных составляющих спектра исходного изображения без удаления низкочастотных составляющих.

Наиболее популярными фильтрами высоких частот являются:

\begin{itemize}

	\item оператор Лапласа.

	Фильтр, основанный на операторе Лапласа, рассматривает изображение как функцию $z = f(x, y)$, где $(x, y)$ - координаты пикселя на изображении, и применяет к ней оператор Лапласа \eqref{ip:2:laplace}:
	\begin{gather}
		\label{ip:2:laplace}
		\left(\dfrac{\partial ^ 2}{\partial x ^ 2} + \dfrac{\partial ^ 2}{\partial y ^ 2}\right) f.
	\end{gather}

	Как видно из формулы \eqref{ip:2:laplace} при расчете оператора Лапласа вычисляются горизонтальные и вертикальный градиенты, что выражено в значениях элементов ядра $K$ фильтра - для простейшего случая $M^* = N^* = 3$ ядро $K$ имеет вид \eqref{ip:2:laplace:K}:
	\begin{gather}
		\label{ip:2:laplace:K}
		K_{33} = \left(
		\begin{array}{ccc}
			0 & 1 & 0 \\
			1 & -4 & 1 \\
			0 & 1 & 0
		\end{array}
		\right).
	\end{gather}

	Библиотека OpenCV реализует оператор Лапласа в виде функции $Laplacian()$, прототип которой приведен в листинге \ref{listing:ip:2:laplace}.
	\mylistingbegin{ip:2:laplace}{Применение к изображению оператора Лапласа с помощью функции Laplacian()}
	\begin{lstlisting}

	void Laplacian(Mat I, Mat & R, int depth, int MN = 1)

	\end{lstlisting}
	\mylistingend

	Функция \verb|Laplacian()| обладает следующими параметрами:
	
	\begin{itemize}

		\item \verb|depth| - тип элемента матрицы \verb|R|.
		
		Параметр \verb|depth| может принимать значение одной из следующих констант компилятора:

		\begin{itemize}

			\item \verb|CV_8U| - 8-ми битное беззнаковое целое;
			\item \verb|CV_32S| - 32-х битное знаковое целое;
			\item \verb|CV_32F| - вещественное одинарной точности;
			\item \verb|CV_64F| - вещественное двойной точности;
			\item прочие константы;

		\end{itemize}

		\item \verb|MN| - размер ядра $K$ фильтра.

		Параметр \verb|MN| может принимать следующие значения:

		\begin{itemize}

			\item 1 - будет использовано ядро $K$ размером 3 x 3 \eqref{ip:2:laplace:K};
			\item 3, 5, 7 - будет использовано ядро $K$ размером \verb|MN| x \verb|MN|;

		\end{itemize}

	\end{itemize}

	\item оператор Собеля.

	Фильтр, основанный на операторе Собеля, позволяет вычислить относительно грубое приближение одной из первых трех производных функции $z = f(x, y)$, описывающей изображение.

	Фильтр, основанный на операторе Собеля, относится к категории пространственных фильтров, выполняющих свертку изображения по ядру $K$. Размер ядра и значения его элементов зависят от того, какие производные по каким направлениям рассчитываются в текущем применении фильтра. Так, например, простейшим случаем являются задачи расчета горизонтального \eqref{ip:2:sobel:hor} и вертикального \eqref{ip:2:sobel:vert} градиентов изображения.
	\begin{gather}
		\label{ip:2:sobel:hor}
		K_{hor} = \left(
		\begin{array}{ccc}
			-1 & -2 & -1 \\
			0 & 0 & 0 \\
			1 & 2 & 1
		\end{array}
		\right) \\
		\label{ip:2:sobel:vert}
		K_{vert} = \left(
		\begin{array}{ccc}
			-1 & 0 & 1 \\
			-2 & 0 & 2 \\
			-1 & 0 & 1
		\end{array}
		\right).
	\end{gather}
	
	Для расчета оператора Собеля библиотека OpenCV предоставляет функцию $Sobel()$, прототип которой приведен в листинге \ref{listing:ip:2:sobel}.
	
	\mylistingbegin{ip:2:sobel}{Применение к изображению оператора Собеля с помощью функции Sobel()}
	\begin{lstlisting}

	void Sobel(Mat I, Mat & R, int depth, int xorder, int yorder, int MN = 3);

	\end{lstlisting}
	\mylistingend

	Функция \verb|Sobel()| принимает следующие параметры:

	\begin{itemize}

		\item \verb|xorder|, \verb|yorder| - порядки вычисляемых производных по горизонтали и вертикали соответственно.

		Параметры \verb|xorder| и \verb|yorder| могут принимать следующие значения: 0, 1, 2, 3. Параметры \verb|xorder| и \verb|yorder| не могут одновременно принимать значение 0;

		\item \verb|MN| - размер ядра $K$ фильтра.

		Параметр \verb|MN| может принимать следующие значения:

		\begin{itemize}

			\item 1 - будет использовано ядро $K$ размером 3 x 3 \eqref{ip:2:laplace:K};
			\item 3, 5, 7 - будет использовано ядро $K$ размером \verb|MN| x \verb|MN|;
			\item значение константы компилятора \verb|CV_SCHARR| - в качестве ядра $K$ будет использовано ядро Щарра \eqref{ip:2:scharr}:
			\begin{gather}
				\label{ip:2:scharr}
				K_{scharr} = \left(
				\begin{array}{ccc}
					-3 & 0 & 3 \\
					-10 & 0 & 10 \\
					-3 & 0 & 3
				\end{array}
				\right).
			\end{gather}

			Ядро Щарра было разработано в попытке улучшить вращательную симметрию оператора Собеля. Библиотека OpenCV предоставляет специальную функцию \verb|Scharr()| для применения фильтра Щарра.

		\end{itemize}

	\end{itemize}

\end{itemize}

\myparagraph{Пороговая обработка изображений}

Важным алгоритмом обработки изображений является алгоритм порогового преобразования изображения.

В общем случае, пороговое преобразование $R = threshold(I, t, h(m, n), l(m, n))$ изображения имеет вид \eqref{ip:2:threshold}:
\begin{gather}
	\label{ip:2:threshold}
	r_{mn} =
	\begin{cases}
		h(m, n) ;~ i_{mn} > t \\
		l(m, n) ;~ i_{mn} \le t
	\end{cases} \\
	m = \overline{1, M} ;~ n = \overline{1, N},
\end{gather}

где:

\begin{itemize}

	\item $t$ - пороговое значение;
	\item $h$, $l$ - верхний и нижний уровни порогового преобразования соответственно.

\end{itemize}

Версии алгоритма порогового преобразования изображения отличаются друг от друга способами определения функций $h(m, n)$ и $l(m, n)$.

Библиотека OpenCV реализует пороговую обработку изображений в виде функции \linebreak \verb|threshold()|, прототип которой приведен в листинге \ref{listing:ip:2:threshold}.
\mylistingbegin{ip:2:threshold}{Пороговая обработка изображения с помощью функции threshold()}
\begin{lstlisting}

double threshold(Mat I, Mat & R, double t, double maxVal, int thresholdType);

\end{lstlisting}
\mylistingend

Тип порогового преобразования задается с помощью параметра \verb|thresholdType|, который может принимать значения следующих констант компилятора:

\begin{itemize}

	\item \verb|THRESH_BINARY| - $h(m, n) = $ \verb|maxVal|; $l(m, n) = 0$;
    \item \verb|THRESH_BINARY_INV| - $h(m, n) = 0$; $l(m, n) = $ \verb|maxVal|;
	\item \verb|THRESH_TRUNC| - $h(m, n) = t$; $l(m, n) = i_{mn}$;
    \item \verb|THRESH_TOZERO| - $h(m, n) = i_{mn}$; $l(m, n) = 0$;
	\item \verb|THRESH_TOZERO_INV| - $h(m, n) = 0$; $l(m, n) = i_{mn}$.

\end{itemize}

\myparagraph{Выделение каналов изображения}

Библиотека OpenCV позволяет выделить каналы изображения с помощью функции \verb|split()|, прототип которой приведен в листинге \ref{listing:ip:2:split}.

\mylistingbegin{ip:2:split}{Выделение каналов изображения с помощью функции split()}
\begin{lstlisting}

void split(Mat I, vector<Mat> & R);

\end{lstlisting}
\mylistingend

Функция \verb|split()| выделяет каналы изображения \verb|I| и помещает их в массив \verb|R| в виде одноканальных изображений.

\myparagraph{Арифметические действия с изображениями}

В таблице \ref{table:ip:2:arlog} перечислены функции библиотеки OpenCV, с помощью которых возможно выполнение разнообразных арифметических и логических операций над матрицами - в том числе, и над изображениями. Все операции выполняются поэлементно над матрицами, размеры которых совпадают.

\newcolumntype{U}{>{\centering\arraybackslash}p{3cm}}
\newcolumntype{V}{>{\centering\arraybackslash}p{14cm}}

\begin{longtable}[H]{|U|V|}

	\multicolumn{2}{r}{Таблица~\thetable~---~Операции~над~матрицами~средствами~библиотеки~OpenCV} \\
	\hline
	\bf Операция & \bf Прототип функции \\
	\hline
	\endhead
	
	\hline
	\endfoot

	\label{table:ip:2:arlog}
	$r_{mn} = i^1_{mn} + i^2_{mn}$ & \verb|add(Mat I1, Mat I2, Mat & R, noArray(), int depth = -1)|\footnote{Значение -1 параметра depth означает, что тип элементов матрицы R совпадает с типом элементов матриц I1 и I2. \label{footnote:depth}} \\
	$r_{mn} = i^1_{mn} - i^2_{mn}$ & \verb|subtract(Mat I1, Mat I2, Mat & R, noArray(), int depth = -1)|\footref{footnote:depth} \\
	$r_{mn} = \alpha i^1_{mn} i^2_{mn}$ & \verb|multiply(Mat I1, Mat I2, Mat & R, double alpha = 1)| \\
	$r_{mn} = \alpha i^1_{mn} / i^2_{mn}$ & \verb|divide(Mat I1, Mat I2, Mat & R, double alpha = 1, int depth = -1)|\footref{footnote:depth} \\
	$r_{mn} = i^\alpha_{mn}$ & \verb|pow(Mat M, double alpha, Mat & R)| \\
	$r_{mn} = \sqrt{i_{mn}}$ & \verb|sqrt(Mat M, Mat & R)| \\
	$r_{mn} = \exp(i_{mn})$ & \verb|exp(Mat M, Mat & R)| \\
	$r_{mn} = \ln(i_{mn})$ & \verb|log(Mat M, Mat & R)| \\
	$r_{mn} = i^1_{mn} \cap i^2_{mn}$ & \verb|bitwise_and(Mat I1, Mat I2, Mat & R)| \\
	$r_{mn} = i^1_{mn} \cup i^2_{mn}$ & \verb|bitwise_or(Mat I1, Mat I2, Mat & R)| \\
	$r_{mn} = i^1_{mn} \oplus i^2_{mn}$ & \verb|bitwise_xor(Mat I1, Mat I2, Mat & R)| \\
	$r_{mn} = ~ i_{mn}$ & \verb|bitwise_and(Mat M, Mat & R)| \\

\end{longtable}

\myparagraph{Операции с контурами}

\mysubparagraph{Аппроксимация контура}

Аппроксимация контура предполагает его сглаживание удалением или замещением части точек контура. Точки - кандидаты на удаление или замещение - могут быть выбраны различными способами - одним из простых способов является обход контура с некоторым окном. Все точки, попадающие в окно, заменяются на одну или несколько точек, аппроксимирующих данный участок контура каким-либо графическим примитивом (например, прямой).

Библиотека OpenCV содержит реализацию алгоритма Рамера - Дугласа - Пекера аппроксимации контура набором полиномов.

Пусть имеется контур $C = \{(x_1, y_1), (x_2, y_2), ..., (x_H, y_H)\} ;~ x_h, y_h \in \mathbb{R}$, где $(x_h, y_h) \in C$ - Декартовы координаты точек контура. Пусть имеется некоторая константа $\epsilon \in \mathbb{R}$. Функция $C' = f(C)$, описывающая алгоритм Рамера - Дугласа - Пекера, имеет вид \eqref{ip:2:pdp}:
\begin{gather}
	\notag d_{max} = \max_{h = \overline{1, H}} d((x_h, y_h), L) \\
	\notag h_{max} = \arg ~ \max_{h = \overline{1, H}} d((x_h, y_h), L) \\
	\label{ip:2:pdp}
	C' = f(C) =
	\begin{cases}
		\{ (x_h, y_h) | d((x_h, y_h), L) \ge \epsilon \} ;~ d_{max} < \epsilon \\
		f(\{ (x_h, y_h) | h \le h_{max} \}) \cup f(\{ (x_h, y_h) | h \ge h_{max} \}) ;~  d_{max} \ge \epsilon 
	\end{cases},
\end{gather}

где:

\begin{itemize}

	\item $L$ - линия, соединяющая точки $(x_1, y_1)$ и $(x_H, y_H)$ (описывается полиномом некоторой степени);
	\item $d((x, y), L)$ - Эвклидово расстояние от точки $(x, y)$ до прямой $L$.

\end{itemize}

Алгоритм Рамера - Дугласа - Пекера реализован библиотекой OpenCV в виде функции \verb|approxPolyDP()|, прототип которой приведен в листинге \ref{listing:ip:2:approx}.

\mylistingbegin{ip:2:approx}{Аппроксимация контура по алгоритму Рамера - Дугласа - Пекера с помощью функции approxPolyDP()}
\begin{lstlisting}

void approxPolyDP(vector<Point> C, vector<Point> C_dash, double epsilon, bool closed);

\end{lstlisting}
\mylistingend

Значение параметра \verb|closed| указывает, является ли контур замкнутым (\verb|true|) или открытым (\verb|false|).

\mysubparagraph{Длина контура}

Для расчета длины контура библиотека OpenCV предоставляет функцию \verb|arcLength()|, прототип которой приведен в листинге \ref{listing:ip:2:len}.

\mylistingbegin{ip:2:len}{Расчет длины контура с помощью функции arcLength()}
\begin{lstlisting}

double arcLength(vector<Point> C, bool closed);

\end{lstlisting}
\mylistingend

\mysubparagraph{Площадь контура}

Для расчета площади поверхности, ограниченной контуром, библиотека OpenCV предоставляет функцию \verb|contourArea()|. Прототип функции \verb|contourArea()| приведен в листинге \ref{listing:ip:2:area}.

\mylistingbegin{ip:2:area}{Расчет площади контура с помощью функции contourArea()}
\begin{lstlisting}

double contourArea(vector<Point> C);

\end{lstlisting}
\mylistingend

\mysubparagraph{Отрисовка контура}

В некоторых случаях оказывается полезным отрисовать контур (контуры) на растровом изображении для дальнейшего вывода изображения на экран. Для отрисовки контуров библиотека OpenCV предоставляет функцию \verb|drawContours()|, прототип которой приведен в листинге \ref{listing:ip:2:drawC}.

\mylistingbegin{ip:2:drawC}{Отрисовка контуров с помощью функции drawContours()}
\begin{lstlisting}

void drawContours(Mat & R, vector<vector<point> > contours, int index, const Scalar & color, int thickness = 1);

\end{lstlisting}
\mylistingend

Функция \verb|drawContours()| обладает следующими параметрами:

\begin{itemize}

	\item \verb|index| - индекс отрисовываемого контура из массива контуров \verb|contours|. Для отрисовки всех контуров из означенного массива в качестве значения параметра \verb|index| в функцию \verb|drawContours()| необходимо передать -1;
	\item \verb|color| - цвет, которым будет отрисован контур.

	Классы \verb|Scalar| и \verb|Vec3b| реализуют неявное приведение значений друг друга.

	Класс \verb|Scalar| обладает статическим конструктором - методом \verb|all()|, прототип которого приведен в листинге \ref{listing:ip:2:scalarall}.

	\mylistingbegin{ip:2:scalarall}{Фабрика объектов класса Scalar - статический метод all() класса Scalar}
	\begin{lstlisting}

	Scalar Scalar::all(double value);

	\end{lstlisting}
	\mylistingend

	Метод \verb|all()| возвращает новый объект класса \verb|Scalar| - описатель пикселя, яркости во всех каналах которого установлены в значение \verb|value|;

	\item \verb|thickness| - толщина линии.

\end{itemize}

