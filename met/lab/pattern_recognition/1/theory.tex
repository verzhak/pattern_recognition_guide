
\myparagraph{Постановка задачи}

Распознавание образов является одним из наиболее активно развиваемых направлений компьютерной графики. Фактически, распознавание образов может рассматриваться в качестве одного из этапов при решении более существенных задач, к коим относятся задачи построения электронных карт по данным дистанционного зондирования Земли, задачи компьютерного зрения и различные другие задачи.

Процесс распознавания образов объектов на том или ином изображений состоит из следующих этапов:

\begin{enumerate}

	\item предварительная обработка изображения.

	На данном этапе изображение подвергается обработке с целью улучшения его свойств, непосредственно влияющих на качество распознавания образов.

	Например, в случае, если изображение содержит отсканированный черно - белый печатный документ, то на этапе обработки изображения целесообразным представляется:

	\begin{itemize}

		\item выполнить размытие изображения фильтром 3 на 3 пикселя, что снизит влияние на конечный результат черных пикселей, попавших на изображение из-за пыли и прочих дефектов, имеющих место быть на носителе и сканирующем устройстве;
		\item применить к изображению один из операторов, выделяющих контруры на изображении (рассчитывающих градиент изображения) - к таковым операторам относятся, например, операторы Canny и Собеля.

	\end{itemize}

	Результатом перечисленных операций станет изображение, на котором будут выделены контуры букв (наиболее значимая информация). Данные о заливке букв и о помехах учитываться в ходе классификации, таким образом, не будут;

	\item поиск образов объектов на изображении.
	
	Поиск образов объектов на изображении предполагает выделение нескольких областей на изображении, в число которых гарантировано точно будут входить области, содержащие изображения искомых объектов.

	Процесс поиска образов на изображении осложнен тем, что задача распознавания образов может решаться для самых разнообразных предметных областей (от распознавания человеческих лиц до поиска графических примитивов), что существенно затрудняет формализацию алгоритма решения задачи. Фактически, для многих предметных областей задача поиска образов решается уникальным алгоритмом.

	С другой стороны, не требуется, чтобы поиск образов на изображении давал набор только тех областей изображения, в которые попадают изображения искомых объектов - наличие некоторого количества <<пустых>> областей допускается, поскольку предполагается, что все таковые области будут отсеяны на этапе классификации образов.

	Важным требованием к этапу поиска образов на изображении является минимизация размеров областей изображения, передаваемых на вход этапа классификации - чем меньше размеры областей, тем, очевидно, проще выполнения классификации.

	Методом, лежащим в основе многих решений задачи поиска образов на изображении, является метод <<грубой силы>> - последовательный проход с определенным шагом всего изображения с окном заданного размера и отсеивание окон, очевидно не содержащих изображения искомых объектов. Для решения наиболее простых задач поиска образов объектов на изображении данный метод подходит без каких - либо модификаций;

	\item классификация образов.

	Задача правильной классификации образов представляет собой интереснейшую оптимизационную задачу, решаемую, на настоящее время, самыми различными алгоритмами, используемыми в зависимости от целей классификации.
	
	В общем случае, классификация образов предполагает построение некоторой функции $y = f(x) ;~ x \in X ;~ y \in \mathbb{N}$, которая принимает на свой вход вектор $x = \{x_1, x_2, ..., x_N\}$ и возвращает номер $y$ класса, к которому вектор $x$ относится.

	Вектор $X$ суть есть {\bf дескриптор} некоторого объекта, класс которого необходимо определить. В контексте рассматриваемой задачи вектором $X$ может стать вектор - дескриптор некоторой области изображения.

	Смысловое наполнение дескриптора различается в зависимости от предметной области, в которой решается задача распознавания образов. Так, например, в качестве дескриптора области изображения могут использоваться следующие вектора:
	
	\begin{itemize}

		\item вектор - построчная развертка области одноканального изображения;
		\item вектор моментов контуров области изображения;
		\item вектор центральных моментов контуров области изображения;
		\item вектор нормализованных центральных моментов контуров области изображения;
		\item вектор моментов Хью контуров области изображения.

	\end{itemize}

	Использование моментов представляется эффективным для решения задачи распознавания символов, поскольку моменты содержат достаточный объем информации для успешного распознавания уникальных контуров букв.

	Ключевым требованием к дескриптору является его адекватность - дескриптор обязательно должен содержать характерные признаки образов и, возможно, ряд несущественных признаков, которые, впрочем, не должны существенным образом влиять на процесс классификации (как правило, влияние несущественных признаков на процесс классификации снижается правильно подобранной функцией $f(x)$).

	Функция $f(x)$ суть есть {\bf классификатор}.

	Существуют самые разнообразные подходы к построению классификаторов, среди которых можно выделить два наиболее часто употребляемых:

	\begin{itemize}

		\item построение классификатора, обучаемого с учителем (обучаемого по множеству векторов, правильная классификация для которых известна).

		К таковым классификаторам относятся наивный Байесовский классификатор, деревья решений, перцептроны, ряд нейроподобных классификаторов (например, машины опорных векторов) и прочие классификаторы.

		Недостатком таковых классификаторов является необходимость создания обучающего множества векторов;

		\item построение классификатора, обучаемого без учителя.

		К таковым классификаторам относятся алгоритм k-means (алгоритм k средних), нейронные карты Кохонена и ряд прочих классификаторов.

		Классификаторы, обучаемые без учителя, выполняют разбиение классифицируемого пространства векторов в соответствии с теми или иными закономерностями, в нем наличествующими (например, алгоритм k-means и нейронные карты Кохонена, использующие Эвклидову меру расстояния, разбивают классифицируемое пространство векторов по принципу минимизации дисперсии в результирующих классах - то есть, используют информацию о статистической структуре пространства - информацию о плотности пространства в тех или иных его областях);

	\end{itemize}

	\item пост - обработка результатов классификации.

	По завершении классификации ее результаты могут быть подвергнуты следующей обработке:

	\begin{itemize}

		\item удаление пустых классов и классов с малым количеством векторов в них;
		\item объединение классов, расположенных близко друг к другу.

		Степень близости классов может быть оценена с помощью одной из мер расстояний - например, с помощью Эвклидова расстояния между центрами классов.

	\end{itemize}

\end{enumerate}

\myparagraph{Алгоритм k-means}

Алгоритм k-means был разработан Г. Штейнгаузом и С. Ллойдом в 50-х годах XX-го века.

Алгоритм k-means разбивает исходное $N$-мерное пространство векторов $X$ на заранее заданное количество $K$ классов, оставляя некоторые из них пустыми. Каждый из непустых классов является связанным подпространством векторов - то есть подпространством, которое невозможно разбить на два непустых непересекающихся открытых подпространства.

Алгоритм k-means состоит из следующих шагов:

\begin{enumerate}

	\item в классифицируемом пространстве случайным образом выбирается $K$ точек - центры каждого из классов;
	\item выполняется классификация векторов пространства - каждый из векторов относится к ближайшему классу. \label{enumerate:1:kmeans:lbegin}

	В качестве меры расстояния до класса используется Эвклидова мера расстояния до центра класса, вычисляемая по формуле \eqref{1:euclid}.
	\begin{gather}
		d(x, x^i) = \sqrt{\sum_{j = 1}^{j < N} (x_j - x_j^i)^2} \label{1:euclid}
	\end{gather}

	В формуле \eqref{1:euclid} вектор $x^i$ суть есть центр $i$-го класса;

	\item если выполняется первая итерация алгоритма или один из центров классов сдвинулся относительно своей предыдущей позиции на величину, превосходящую некоторый порог, то выполняется переход к шагу \ref{enumerate:1:kmeans:next}, иначе - алгоритм останавливается;
	\item центры классов пересчитываются - новый центр класса формируется из эмпирических математических ожиданий каждой из компонент векторов, отнесенных к классу; \label{enumerate:1:kmeans:next}
	\item выполняется переход на шаг \ref{enumerate:1:kmeans:lbegin}.

\end{enumerate}
	
\myparagraph{Программная библиотека OpenCV}

\mysubparagraph{Расчет пространственных моментов контуров образов объектов на изображении}

В качестве дескрипторов изображений в ходе решения простейших задач распознавания образов могут быть использованы пространственные моменты контуров образов объектов на изображениях:

\begin{itemize}

	\item моменты $m_{kl}$, рассчитываемые по формуле \eqref{1:moment:kl}.
	\begin{gather}
		m_{kl} = \sum_{i = 1}^{i < N} \sum_{j = 1}^{j < N} point(i, j) ~ i^k ~ j^l \label{1:moment:kl}
	\end{gather}

	В формуле \eqref{1:moment:kl}:

	\begin{itemize}

		\item $point(i, j)$ - координаты $(i, j)$-ой точки контура;
		\item $N$ - количество точек в контуре;

	\end{itemize}

	\item центральные моменты $\mu_{kl}$, рассчитываемые по формуле \eqref{1:moment:center}.
	\begin{gather}
		\mu_{kl} = \sum_{i = 1}^{i < N} \sum_{j = 1}^{j < N} point(i, j) ~ (i - \overline{i})^k ~ (j - \overline{j})^l \label{1:moment:center} \\
		\overline{i} = \dfrac{m_{10}}{m_{00}} ;~ \overline{j} = \dfrac{m_{01}}{m_{00}} \notag
	\end{gather}

	При этом необходимо учитывать, что $\mu_{10} = \mu_{01} = 0$;

	\item нормализованные центральные моменты $\eta_{kl}$, рассчитываемые по формуле \eqref{1:moment:normal}.
	\begin{gather}
		\eta_{kl} = \dfrac{\mu_{kl}}{m_{00}^{(i + j) / 2 + 1}} \label{1:moment:normal}
	\end{gather}

	При этом необходимо учитывать, что $\eta_{00} = 1$ и $\eta_{10} = \eta_{01} = 0$;

	\item моменты, инвариантные к повороту, изменению масштаба и к некоторым другим преобразованиям изображения - семь моментов Хью \eqref{1:moment:hu}.
	\begin{gather}
		\label{1:moment:hu}
		\begin{align}
		hu_1 =~ & \eta_{20} + \eta_{02} \\
		hu_2 =~ & (\eta_{20} - \eta_{02})^2 + 4 \eta_{11}^2 \notag \\
		hu_3 =~ & (\eta_{30} - 3 \eta_{12})^2 + (3 \eta_{21} - \eta_{03})^2 \notag \\
		hu_4 =~ & (\eta_{30} + \eta_{12})^2 + (\eta_{21} + \eta_{03})^2 \notag \\
		hu_5 =~ & (\eta_{30} - 3 \eta_{12}) (\eta_{30} + \eta_{12})((\eta_{30} + \eta_{12})^2 - 3 (\eta_{21} + \eta_{03})^2) + \notag \\
			   & (3 \eta_{21} - \eta_{03}) (\eta_{21} + \eta_{03})(3 (\eta_{30} + \eta_{12})^2 -  (\eta_{21} + \eta_{03})^2) \notag \\
		hu_6 =~ & (\eta_{20} - \eta_{02})((\eta_{30} + \eta_{12})^2 - (\eta_{21} + \eta_{03})^2) + 4 \eta_{11}(\eta_{30} + \eta_{12})(\eta_{21} + \eta_{03}) \notag \\
		hu_7 =~ & (3 \eta_{21} - \eta_{03})(\eta_{03} + \eta_{21})(3 (\eta_{30} + \eta_{12})^2 - (\eta_{21} + \eta_{03})^2) - \notag \\
			   & (\eta_{30} - 3 \eta_{12})(\eta_{03} + \eta_{21})(3 (\eta_{30} + \eta_{12})^2 - (\eta_{21} + \eta_{03})^2) \notag
		\end{align}
	\end{gather}

\end{itemize}

Для поиска контуров на изображении необходимо воспользоваться функцией \verb|findContours()|, прототип которой приведен в листинге \ref{listing:1:contour}.

\mylistingbegin{1:contour}{Поиск контуров на изображении с помощью функции findContours()}
\begin{lstlisting}

void findContours(Mat image, vector<vector<Point> > & contours, int mode, int method);

\end{lstlisting}
\mylistingend

Функция \verb|findContours()| обладает следующими параметрами:

\begin{itemize}

	\item \verb|image| - описатель матрицы изображения (изображение должно быть одноканальным);
	\item \verb|contours| - массив, в котором функция \verb|findContours()| сохраняет массивы точек найденных ею контуров;
	\item \verb|mode| - способ сохранения массивов точек контуров в массиве \verb|contours|.

	Параметр \verb|mode| может принимать различные значения, в число которых входят следующие:

	\begin{itemize}

		\item \verb|CV_RETR_EXTERNAL| - в массиве \verb|contours| сохраняется только внешний (охватывающий все остальные контуры) контур;
		\item \verb|CV_RETR_LIST| - в массиве \verb|contours| сохраняются все контура без какой - либо дополнительной их сортировки;

	\end{itemize}

	\item \verb|method| - идентификатор метода аппроксимации (сглаживания) контура.

	При аппроксимации контура часть точек из него удаляется, а часть - заменяется новыми.

	Параметр \verb|method| может принимать следующие значения:

	\begin{itemize}

		\item \verb|CV_CHAIN_APPROX_NONE| - аппроксимация не производится;
		\item \verb|CV_CHAIN_APPROX_SIMPLE| - простейшая аппроксимация;
		\item \verb|CV_CHAIN_APPROX_TC89_L1|, \verb|CV_CHAIN_APPROX_TC89_KCOS| - для аппроксимации применяется алгоритм Teh - Chin различных версий, предложенный C.H. Teh и R.T. Chin в 1989-ом году.

	\end{itemize}

\end{itemize}

Для расчета моментов, центральных моментов и нормализованных центральных моментов контура необходимо воспользоваться функцией \verb|moments()|, прототип которой приведен в листинге \ref{listing:1:moments}.

\mylistingbegin{1:moments}{Расчет моментов, центральных моментов и нормализованных центральных моментов с помощью функции moments()}
\begin{lstlisting}

Moments moments(vector<Point> contour);

\end{lstlisting}
\mylistingend

Функция \verb|moments()| рассчитывает указанные моменты для контура, массив точек которого передан в функцию первым параметром.

Вычисленные моменты функция \verb|moments()| возвращает в объекте - экземпляре класса \verb|Moments|.

Для расчета моментов Хью контура можно воспользоваться функцией \verb|HuMoments()|, прототип которой приведен в листинге \ref{listing:1:hu}.

\mylistingbegin{1:hu}{Расчет моментов Хью с помощью функции HuMoments()}
\begin{lstlisting}

void HuMoments(const Moments & moments, double * hu);

\end{lstlisting}
\mylistingend

По моментам (первый параметр) контура, рассчитанным с помощью функции \verb|moments()|, функция \verb|HuMoments()| рассчитывает семь моментов Хью и сохраняет их в массиве, указатель на который передан в функцию вторым параметром.

\mysubparagraph{Алгоритм k-means}

Для классификации пространства векторов с помощью алгоритма k-means необходимо воспользоваться функцией \verb|kmeans()|, прототип которой приведен в листинге \ref{listing:1:kmeans}.

\mylistingbegin{1:kmeans}{Классификация пространства векторов с помощью алгоритма k-means и функции kmeans()}
\begin{lstlisting}

double kmeans(Mat samples, int clusterCount, Mat labels, TermCriteria criteria, int attempts, int flags, Mat centers);

\end{lstlisting}
\mylistingend

Функция \verb|kmeans()| обладает следующими параметрами:

\begin{itemize}

	\item \verb|samples| - матрица классифицируемых векторов.

	Данная матрица состоит из $M$ строк (каждая строка суть есть вектор) и $N$ столбцов (по размерности пространства).

	Очевидно, что, если в качестве дескриптора изображений используются моменты Хью, количество и тип каналов матрицы \verb|samples| задается константой \verb|CV_32FC1| компилятора (матрица \verb|samples|, таким образом, является одноканальной вещественной одинарной точности; двойная точность не используется по причине необходимости сокращения времени выполнения алгоритма);

	\item \verb|clusterCount| - количество классов;
	\item \verb|labels| - матрица меток векторов.
	
	Матрица \verb|labels| состоит из $M$ строк и единственного столбца. Формат матрицы - \verb|CV_32SC1|; матрица \verb|labels| является, таким образом, одноканальной 32-х битной знаковой.

	Алгоритм k-means сохраняет в матрицу \verb|labels| номера классов, к которым отнесены соответствующие вектора. Нумерация классов начинается с нуля;

	\item \verb|criteria| - критерий останова.

	Существуют следующие критерии останова:

	\begin{itemize}

		\item выполнение максимально допустимого числа итераций;
		\item достижение пороговой величины сдвига центров классов.

	\end{itemize}

	В простейших задачах рекомендуется использовать в качестве критерия останова алгоритма только второй критерий, что соответствует значению параметра \verb|critical|: \verb|TermCriteria(CV_TERMCRIT_EPS, 0, 0.00001)| - здесь \verb|0.00001| - максимально допустимый для останова алгоритма сдвиг центров классов относительно своих предыдущих позиций;

	\item \verb|attempts| - количество прогонов алгоритма, среди результатов работы которых в дальнейшем будет выбран наилучший (по принципу минимизации суммарной дисперсии классов);

	\item \verb|flags| - маска флагов.
		
	Параметр \verb|flags| может принимать одно из следующих значений:

	\begin{itemize}

		\item \verb|KMEANS_RANDOM_CENTERS| - на первой итерации алгоритма компонентам векторов - центров классов будут присвоены случайные значения;
		\item \verb|KMEANS_PP_CENTERS| - применяется алгоритм k-means++ расчета начальных значений компонент векторов - центров классов, предложенный D. Arthur и S. Vassilvitskii в 2007-м году;

	\end{itemize}

	\item \verb|centers| - матрица центров классов.

	Матрица \verb|centers| состоит из \verb|clusterCount| строк (каждая строка суть есть вектор - центр соответствующего класса) и $N$ столбцов (по размерности пространства). Формат матрицы - \verb|CV_32FC1|; элементы матрицы \verb|centers| являются, таким образом, 32-х битными вещественными числами.

\end{itemize}

Функция \verb|kmeans()| возвращает сумму дисперсий классов. Чем меньше значение, возвращаемое функцией \verb|kmeans()|, тем лучше.

